# TimeService 

## What You Learn

*   How to write an application service acting as a so called inbound-port 
*   How to declare an outbound-port sending current time   
*   How to provide an implementation of this outbound-port, a so called driving adapter, with console output
*   How to provide an implementation of this outbound-port using `DrivenAdapterStrategy` from Jexxa for JMS.
*   How to use a so called `specific adapter` provided by Jexxa together with an application specific driving adapter    

## What you need

*   Understand tutorial `HelloJexxa` because we explain only new aspects 
*   60 minutes
*   JDK 11 (or higher) installed 
*   Maven 3.6 (or higher) installed
*   A running ActiveMQ instance (at least if you start the application with option `-jms`)
*   curl or jconsole to trigger the application  

## 1. Implementing Application Core 

The application core consists of following two classes:

*   `TimeService`: Provides uses cases of the domain and is a `ApplicationService` in terms of the pattern language of DDD
*   `ITimePublisher`: Allows for publishing current time and is a `DomainService` in terms of the pattern language of DDD        

### Implement class `TimeService` 

This class provides the supports the main two very simple use cases of this application: 
*   Provide current time
*   Publish current time in any way.   

The most important aspect here is that a technology-agnostic application must not use any technology-stack. Therefore, 
we must define an interface `ITimePublisher` that provides us the possibility to publish the time by an arbitrary technology stack.

Since Jexxa only supports implicit constructor injection, we have to declare all required interfaces in the constructor.    

```java
public class TimeService
{
    private final ITimePublisher timePublisher;

    /**
     * Note: Jexxa supports only implicit constructor injection. Therefore, we must
     * declare all required interfaces in the constructor.  
     *
     * @param timePublisher required outbound port for this application service
     */
    public TimeService(ITimePublisher timePublisher)
    {
        this.timePublisher = timePublisher;
    }

    public LocalTime getTime()
    {
        return LocalTime.now();
    }
    
    public void publishTime()
    {
        timePublisher.publish(getTime());
    }
}
```                  

### Declare interface `ITimePublisher`

The interface is quite simple since we need just a single method to publish a time. 

```java
public interface ITimePublisher
{
    void publish(LocalTime localTime);
}
```                  

## 2. Implement the Infrastructure

### Driven Adapter with console output 
The implementation is quite simple and just prints given time to a logger.  

Note: Jexxa uses implicit constructor injection together with a strict convention over configuration approach.

Therefore, each driven adapter needs one of the following constructors: 

*   A public default constructor
*   A public constructor with a single `Properties` attribute
*   A public static factory method that gets no parameters and returns the type of the driving adapter
*   A public static factory method with a single `Properties` parameter and returns the type of the requested driving adapter
   
Since our driven adapter does not need/support any configuration parameter, we can use default constructor generated by Java.

Note: In case you use any static code analysis tools such as SonarCube you can add annotation `@SuppressWarnings("unused")` to avoid a warning the class is not used. 

```java
@SuppressWarnings("unused")
public class ConsolePublisher implements ITimePublisher
{

    private static final Logger LOGGER = JexxaLogger.getLogger(ConsolePublisher.class);

    @Override
    public void publish(LocalTime localTime)
    {
        Validate.notNull(localTime);

        var logMessage = localTime.format(DateTimeFormatter.ISO_TIME);

        LOGGER.info(logMessage);
    }
}
```

### Driven Adapter with JMS

Jexxa provides so called `DrivenAdapterStrategy` for various Java-APIs such as JMS. When using these strategies the implementation of a driven adapter is just a facade and maps domain specific methods to the technology stack. In the following implementation we use the `JMSSender` provided by Jexxa.   

Note: Since `JMSSender` requires information from a `Properties` we must provide a constructor or static factory method with a `Properties` attribute. By default, Jexxa hands in all information from jexxa-application.properties file. This file can extended by application specific information such as the topic name if required.        

```java
@SuppressWarnings("unused")
public class JMSPublisher implements ITimePublisher
{
    private static final String TIME_TOPIC = "TimeService";

    private final MessageSender messageSender;

    // For all driven adapter we have to provide either a static factory or a public constructor to
    // enable implicit constructor injection
    public JMSPublisher(Properties properties)
    {
        //Request a default message Sender from corresponding strategy manager  
        this.messageSender = MessageSenderManager.getInstance().getStrategy(properties);
    }

    @Override
    public void publish(LocalTime localTime)
    {
        // Send the message to the topic.
        messageSender.send(localTime)
                .toTopic(TIME_TOPIC)
                .asJson();
    }
}
```

Typically, information stated in `jexxa-application.properties` for JMS are as follows: 

```properties
#suppress inspection "UnusedProperty" for whole file
#Settings for JMSAdapter and JMSSender
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory
java.naming.provider.url=tcp://localhost:61616
java.naming.user=admin
java.naming.password=admin
```                       

## 3. Implement the port adapter to receive JMS messages
When receiving asynchronous messages we have to convert it into business data which is defined in the application core and forward it to a specific method within the application core. Since this cannot be done by convention meaningful, we have to use a configuration approach. As described in [Architecture of Jexxa](https://repplix.github.io/Jexxa/jexxa.html), we have to implement a so called port adapter.   
  
Implementing a port adapter for JMS is quite easy.
*   Within the constructor we define our class from the application core that will be called. Jexxa automatically injects this object when creating the port adapter. By convention, this is the only object defined in the constructor.  
*   In case of JMS we have to implement the `MessageListener` interface and the corresponding `onMessage` method. 
*   Then we have to pass the configuration parameter the specific driving adapter. In this case it is called `JMSConfiguration` and allows to define all JMS related information, such as destination, messaging type, and a messaging selector if required.            
  
```java
@SuppressWarnings("unused")
public class PublishTimeListener implements MessageListener
{
    private final TimeService timeService;
    private static final String TIME_TOPIC = "TimeService";

    //To implement a so called PortAdapter we need a public constructor which expects a single argument that must be an InboundPort.
    public PublishTimeListener(TimeService timeService)
    {
        this.timeService = timeService;
    }

    @Override
    // The JMS specific configuration is defined via annotation.
    @JMSConfiguration(destination = TIME_TOPIC, messagingType = JMSConfiguration.MessagingType.TOPIC)
    public void onMessage(Message message)
    {
        // The JMSSender sends all messages as TextMessage in Json encoding
        var textMessage = (TextMessage)message;
        try
        {
            // Deserialize the message which is of type 'LocalTime'
            var time = new Gson().fromJson(textMessage.getText(), LocalTime.class);

            // Forward this information to corresponding application service. 
            timeService.timePublished(time);
        }
        catch (JMSException jmsException)
        {
            JexxaLogger.getLogger(PublishTimeListener.class).error(jmsException.getMessage());
        }

    }
}
```

## 4. Implement the Application 

Finally, we have to write our application. As you can see in the code below there are two main differences compared to `HelloJexxa`:

*   We define the packages that should be used by Jexxa. This allows fine-grained control of used driven adapter since we must offer only a single implementation for each outbound port. In addition, this limits the search space for potential driven adapters and speeds up startup time.
*   Depending on the command line parameters we decide which driven adapter should be used to publish the time, JMS based or console based.
*   In case we use JMS, we connect JMSAdapter to the application specific port adapter.     
*   The rest of the main method is similar to `HelloJexxa` tutorial.   
   
```java
public final class TimeServiceApplication
{
    //Declare the packages that should be used by Jexxa
    private static final String JMS_DRIVEN_ADAPTER      = TimeServiceApplication.class.getPackageName() + ".infrastructure.drivenadapter.messaging";
    private static final String CONSOLE_DRIVEN_ADAPTER  = TimeServiceApplication.class.getPackageName() + ".infrastructure.drivenadapter.console";
    private static final String OUTBOUND_PORTS          = TimeServiceApplication.class.getPackageName() + ".domainservice";

    public static void main(String[] args)
    {
        JexxaMain jexxaMain = new JexxaMain("TimeService");

        jexxaMain
                //Define which outbound ports should be managed by Jexxa
                .addToApplicationCore(OUTBOUND_PORTS)
                
                //Define the driving adapter that should which implementation of the outbound port should be used by Jexxa.
                //Note: We must only register a single driven adapter for the outbound port
                .addToInfrastructure(getDrivenAdapter(args));

                // If JMS is enabled bind 'JMSAdapter' to our application 
                // Note: Jexxa's JMSAdapter is a so called specific driving adapter which cannot be directly connected directly
                // to an inbound port because we cannot apply any convention. In this case bind Jexxa's specific driving adapter
                // 'JMSAdapter' to an application specific DrivingAdapter which is `PublishTimeListener`
                if ( isJMSEnabled(args) )
                {
                    jexxaMain.bind(JMSAdapter.class).to(PublishTimeListener.class);
                }


        //The rest of main is similar to tutorial HelloJexxa
        jexxaMain
                // Bind RESTfulRPCAdapter and JMXAdapter to TimeService class so that we can invoke its method
                .bind(RESTfulRPCAdapter.class).to(TimeService.class)
                .bind(JMXAdapter.class).to(TimeService.class)

                .bind(JMXAdapter.class).to(jexxaMain.getBoundedContext())
                .bind(RESTfulRPCAdapter.class).to(jexxaMain.getBoundedContext())

                .start()

                .waitForShutdown()

                .stop();
    }
}
```  

That's it. 

## Compile & Start the Application with console output 

```console                                                          
mvn clean install
java -jar target/timeservice-jar-with-dependencies.jar 
```
You will see following (or similar) output
```console
[main] INFO io.jexxa.core.JexxaMain - Start BoundedContext 'TimeService' with 2 Driving Adapter 
[main] INFO org.eclipse.jetty.util.log - Logging initialized @644ms to org.eclipse.jetty.util.log.Slf4jLog
[main] INFO io.javalin.Javalin - Starting Javalin ...
[main] INFO io.javalin.Javalin - Listening on http://localhost:7000/
[main] INFO io.javalin.Javalin - Javalin started in 121ms \o/
[main] INFO io.jexxa.core.JexxaMain - BoundedContext 'TimeService' successfully started in 0.649 seconds
```          

### Publish the time 

You can use curl to publish the time.  
```Console
curl -X POST http://localhost:7000/TimeService/publishTime
```

Each time you execute curl you should see following output on console: 

```console                                                          
[qtp2095064787-31] INFO io.jexxa.tutorials.timeservice.infrastructure.drivenadapter.console.ConsolePublisher - 19:17:12.998278
```

## Compile & Start the Application with JMS 

```console                                                          
mvn clean install
java -jar target/timeservice-jar-with-dependencies.jar -j 
```
You will see following (or similar) output
```console
[main] INFO io.jexxa.core.JexxaMain - Start BoundedContext 'TimeService' with 2 Driving Adapter 
[main] INFO org.eclipse.jetty.util.log - Logging initialized @644ms to org.eclipse.jetty.util.log.Slf4jLog
[main] INFO io.javalin.Javalin - Starting Javalin ...
[main] INFO io.javalin.Javalin - Listening on http://localhost:7000/
[main] INFO io.javalin.Javalin - Javalin started in 121ms \o/
[main] INFO io.jexxa.core.JexxaMain - BoundedContext 'TimeService' successfully started in 0.649 seconds
```          

### Publish the time
 
You can use curl to publish the time.  
```Console
curl -X POST http://localhost:7000/TimeService/publishTime
```

Each time you execute curl you should see following output on console: 

```console                                                          
[qtp26757919-34] INFO io.jexxa.tutorials.timeservice.infrastructure.drivenadapter.messaging.JMSPublisher - Successfully published time 19:18:52.992826 to topic TimeService
```
